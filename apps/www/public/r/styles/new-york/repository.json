{
  "$schema": "https://ui.ftech.ltd/schema/registry-item.json",
  "name": "repository",
  "type": "registry:block",
  "author": "shadcn (https://ui.ftech.ltd)",
  "description": "A collection of repository components",
  "dependencies": [
    "js-cookie",
    "@tanstack/react-query",
    "axios",
    "numeral",
    "dayjs"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "blocks/repository/data/[module]/index.ts",
      "content": "import { useMutation, useQuery } from \"@tanstack/react-query\"\nimport Cookies from \"js-cookie\"\n\nimport { Model } from \"../../data\"\nimport { IServiceConstructorData } from \"../core/net\"\n\nfunction getToken() {\n  let token = Cookies.get(\"token\")\n  if (!token) return\n  return `Bearer ${token}`\n}\n\nexport interface IModule {}\n\nexport class Module extends Model {}\n\nconst modelConfig: IServiceConstructorData = {\n  path: \"/\",\n  baseUrl: process.env.API_URL || \"http://localhost:8080\",\n  auth: getToken,\n}\n\nModule.setup(modelConfig)\n\nexport function useCreateModule(data: any) {\n  return useMutation({\n    mutationKey: [\"createModule\"],\n    mutationFn: () => Module.create(data),\n  })\n}\n\nexport function useGetModule(id: string) {\n  return useQuery({\n    queryKey: [\"getModule\", id],\n    queryFn: () => Module.get(id),\n  })\n}\n\nexport function useUpdateModule(id: string, data: any) {\n  return useMutation({\n    mutationKey: [\"updateModule\", id],\n    mutationFn: () => Module.update(id, data),\n  })\n}\n\nexport function useDeleteModule(id: string) {\n  return useMutation({\n    mutationKey: [\"deleteModule\", id],\n    mutationFn: () => Module.delete(id),\n  })\n}\n",
      "type": "registry:lib",
      "target": "data/[module]/index.ts"
    },
    {
      "path": "blocks/repository/data/core/model.ts",
      "content": "import { Api, type IServiceConstructorData } from \"../core/net\"\n\n/**\n * Core model, every model extend this class have a static init method use to implement http service adapter,\n * that's all\n */\nexport class Model {\n  static api: Api\n  static path: string\n  static setup(\n    modelConfig: IServiceConstructorData = {\n      path: \"\",\n    }\n  ) {\n    this.api = new Api(modelConfig)\n    this.path = modelConfig.path\n  }\n  // create\n  static create(data: any) {\n    return this.api.post({\n      url: this.path,\n      data,\n    })\n  }\n  static get(id: string) {\n    return this.api.get({\n      url: `${this.path}/${id}`,\n    })\n  }\n  // update\n  static update(id: string, data: any) {\n    return this.api.put({\n      url: `${this.path}/${id}`,\n      data,\n    })\n  }\n  // delete\n  static delete(id: string) {\n    return this.api.delete({\n      url: `${this.path}/${id}`,\n    })\n  }\n  // list\n  static list(params: any) {\n    return this.api.get({\n      url: this.path,\n      params,\n    })\n  }\n}\n",
      "type": "registry:lib",
      "target": "data/core/model.ts"
    },
    {
      "path": "blocks/repository/data/core/net/api.ts",
      "content": "import axios, {\n  AxiosError,\n  type AxiosInstance,\n  type AxiosRequestConfig,\n  type CreateAxiosDefaults,\n} from \"axios\"\nimport Cookies from \"js-cookie\"\n\ninterface IServerError {\n  detail: string\n  message: string\n  error: string\n  errors: Record<string, string[]> | string[][]\n}\n\nexport interface IHttpError {\n  status?: number\n  status_code?: string\n  message: string\n  errors: Record<string, string[]> | string[][] | undefined\n}\n\nexport interface IServiceConstructorData {\n  /**\n   * The API Server base path, for example `/posts`\n   */\n  path: string\n  baseUrl?: string\n  auth?: () => string | undefined\n}\n\nexport class Api {\n  http: AxiosInstance = axios.create()\n\n  path = \"\"\n\n  /**\n   * The service setting up responsibilities are:\n   * - Set up the http client base url\n   * @param config\n   */\n  constructor(config: IServiceConstructorData) {\n    const { path, baseUrl, auth } = config\n    this.path = path\n    let Authorization = undefined\n    if (typeof window !== \"undefined\") {\n      Authorization = auth?.()\n    }\n\n    const instanceConfig: CreateAxiosDefaults = {\n      headers: {\n        Authorization,\n      },\n      baseURL: baseUrl,\n    }\n\n    this.http = axios.create(instanceConfig)\n    this.http.interceptors.response.use((config) => config, this.handleError)\n    this.http.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        if (error.status === 401) {\n          Cookies.remove(process.env.AUTH_KEY || \"accessToken\")\n          location.reload()\n        }\n        return this.handleError(error)\n      }\n    )\n  }\n\n  handleError(err: AxiosError<Partial<IServerError>>) {\n    console.log(err)\n    const finalError: IHttpError = {\n      status: err.response?.status || err.status,\n      message:\n        err?.response?.data?.detail ||\n        err?.response?.data?.message ||\n        err?.response?.data?.error ||\n        err.message,\n      errors: err.response?.data.errors,\n    }\n\n    return Promise.reject(finalError)\n  }\n\n  /**\n   * Overwrite GET method\n   * @param config\n   */\n  get<T>(config: AxiosRequestConfig = {}) {\n    const { url = this.path, ...requestConfig } = config\n    return this.http.get<T>(url, requestConfig)\n  }\n\n  /**\n   * Overwrite POST method\n   * @param config\n   */\n  post<T>(config: AxiosRequestConfig = {}) {\n    const { url = this.path, data, ...params } = config\n    return this.http.post<T>(url, data, params)\n  }\n\n  /**\n   * Overwrite POST FormData method\n   * @param config\n   */\n\n  postFormData<T>(config: AxiosRequestConfig = {}) {\n    const token = Cookies.get(process.env.AUTH_KEY || \"accessToken\")\n    const { url = this.path, data, ...params } = config\n    const headers = {\n      Authorization: token ? `Bearer ${token}` : undefined,\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    }\n    return this.http.post<T>(url, data, { ...params, headers })\n  }\n\n  /**\n   * Overwrite PUT method\n   * @param config\n   */\n  put<T>(config: AxiosRequestConfig = {}) {\n    const { url = this.path, data, ...requestConfig } = config\n\n    return this.http.put<T>(url, data, requestConfig)\n  }\n\n  putFormData<T>(config: AxiosRequestConfig = {}) {\n    const token = Cookies.get(process.env.AUTH_KEY || \"accessToken\")\n    const { url = this.path, data, ...params } = config\n    const headers = {\n      Authorization: token ? `Bearer ${token}` : undefined,\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    }\n    return this.http.put<T>(url, data, { ...params, headers })\n  }\n\n  /**\n   * Overwrite PATCH method\n   * @param config\n   */\n  patch<T>(config: AxiosRequestConfig = {}) {\n    const { url = this.path, data, ...requestConfig } = config\n    return this.http.patch<T>(url, data, requestConfig)\n  }\n\n  /**\n   * Overwrite DELETE method\n   * @param config\n   */\n  delete<T>(config: AxiosRequestConfig = {}) {\n    const { url = this.path, ...requestConfig } = config\n\n    return this.http.delete<T>(url, requestConfig)\n  }\n\n  /**\n   * Upload\n   * @return {Promise<T>}\n   * @param config\n   */\n  upload<T>(config: AxiosRequestConfig = {}) {\n    const { url = this.path, data, ...requestConfig } = config\n\n    return this.http.post<T>(url, data, {\n      ...requestConfig,\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n      },\n    })\n  }\n\n  uploadFile<T>(url: string, file: File) {\n    const formData = new FormData()\n    formData.append(\"file\", file)\n\n    return this.upload<T>({ url, data: formData })\n  }\n\n  /**\n   * Upload single file\n   * @param {File} file\n   * @param {string} url\n   * @return {Promise<T>}\n   */\n  uploadSingleFile<T>(url: string, file: File, store_id: string) {\n    const formData = new FormData()\n    formData.append(\"file\", file)\n    formData.append(\"store_id\", store_id)\n\n    return this.upload<T>({ url, data: formData })\n  }\n\n  /**\n   * Download single file\n   * @param url\n   * @param fileName\n   */\n  async downloadFile(\n    url: string,\n    fileName: string,\n    options?: AxiosRequestConfig\n  ) {\n    const { data } = await this.http.get(url, {\n      ...options,\n      responseType: \"blob\",\n    })\n\n    const link = document.createElement(\"a\")\n    link.href = URL.createObjectURL(new Blob([data]))\n    link.setAttribute(\"download\", fileName)\n    document.body.appendChild(link)\n    link.click()\n  }\n}\n",
      "type": "registry:lib",
      "target": "data/core/net/api.ts"
    },
    {
      "path": "blocks/repository/data/core/net/index.ts",
      "content": "export * from \"./api\"\n",
      "type": "registry:lib",
      "target": "data/core/net/index.ts"
    },
    {
      "path": "blocks/repository/data/index.ts",
      "content": "export * from \"./[module]\"\nexport * from \"./core/model\"\n",
      "type": "registry:lib",
      "target": "data/index.ts"
    },
    {
      "path": "blocks/repository/lib/helper.ts",
      "content": "import dayjs from \"dayjs\"\nimport numeral from \"numeral\"\n\n// Split helpers into categories for better organization and maintainability.\n\n// Number formatting helper\nexport function formatNumber(value: number, format: string = \"0,0\"): string {\n  return numeral(value).format(format)\n}\n\n// Date-time formatting helper\nexport function formatDate(\n  date: string | Date,\n  format: string = \"YYYY-MM-DD\"\n): string {\n  return dayjs(date).format(format)\n}\n\n// Array Helpers\nexport function removeDuplicates<T>(array: T[]): T[] {\n  return Array.from(new Set(array))\n}\n\nexport function arrayIntersection<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((value) => array2.includes(value))\n}\n\n// Local Storage Helpers\nexport function saveToLocalStorage(key: string, value: any): void {\n  localStorage.setItem(key, JSON.stringify(value))\n}\n\nexport function getFromLocalStorage<T>(key: string): T | null {\n  const item = localStorage.getItem(key)\n  return item ? JSON.parse(item) : null\n}\n\n// Validation Helpers\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  return emailRegex.test(email)\n}\n\nexport function isValidURL(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch {\n    return false\n  }\n}\n\n// String Manipulation Helpers\nexport function capitalizeFirstLetter(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function toCamelCase(str: string): string {\n  return str\n    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())\n    .replace(/^(.)/, (_, char) => char.toLowerCase())\n}\n\nexport function toKebabCase(str: string): string {\n  return str\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/\\s+/g, \"-\")\n    .toLowerCase()\n}\n",
      "type": "registry:lib",
      "target": "lib/helper.ts"
    }
  ]
}